CoWR.alias: PoaWR Frai
MP.alias3+rfi-data+dmb: Rfai DpDatadW Rfe DMB.SYdRR Fre
PPOCA.alias: DMB.SYdWW Rfe DpCtrldW Rfai DpAddrdR Fre
CoWTf.inv+po: PosWR Tfrim
CoRpteTf.inv+po: Rfe PosRR Tfrem
LB.TT.inv+pos: PodRW Trfem PodRW Trfem
CoTW1.inv: PosRW Trfim
CoWTf.inv+dsb-isb: DSB.SY+ISBsWR Tfrim
#CoTTf.inv+dsb-isb: Trfem DSB.SY+ISBsRR Tfrem
CoRpteTf.inv+dsb-isb: Rfe DSB.SY+ISBsRR Tfrem
#CoTTf.inv+ctrl-isb (ignore the EOR): Trfe, control dependency + ISB, Tfre [need combined Dpd/barriers]
CoRpteTf.inv+addr: Rfe DpAddrsR Tfrem
CoWTf.inv+dmb: DMB.SYsWR Tfrim
#R.TR.inv+dmb+trf: any even number is an invalid entry (including 2); DMB Coe Trfi Frae
MP.RTf.inv+dmb+ctrl: DMB.SYdWW Rfe DpCtrldR Tfrem
MP.RT.inv+dmb+ctrl-trfi: DMB.SYdWW Rfe DpCtrldW Trfim Frae
WRC.TRTf.inv+po+dsb-isb: Trfem PodRW Rfe DSB.SY+ISBdRR Tfrem
WRC.RRTf.inv+dmb+dsb-isb: Rfe DSB.SYdRW Rfe DSB.SY+ISBdRR Tfrem
WRC.TRR.inv+po+dsb: Trfem PodRW Rfe DSB.SYdRR Fre
CoWinvT+po: PosWR Tfrib
# Section 8.5: same but break rather than make (mostly?)
CoWinvT+dsb-isb: DSB.SY+ISBsWR Tfrib
#MP.RT.inv+polocdmb+ctrl-isb: Coi DMB Rfe Control+isb (inverse Trf* - mini extension?)
#CoTfT+dsb-isb: Trfeb DSB.SY+ISBsRR Tfreb
#CoWinvT.EL1+dsbtlbi-dsb-isb: TLBI kind of like a read of x, DSBsTLBI, DSB+ISB, Tfri
#CoWinvT.EL1+tlbidsb-isb: variant of the above
#MP.RT.EL1+dsb-tlbiisdsb+dsb-isb: DSBs to this specific kind of TLBI, DSB, Rfe, DSB+ISB, Tfre
#RBS+dsb-tlbiis-dsb: f1 first. Tfre, DSBsTLBI, DSB, Rfe, inverse of intra-instruction
#RBS+dsb-tlbiisdsb+poloc: same but thread 1 reads x twice
#BBM+dsb-tlbiis-dsb (no cycle connecting e to f): Tfre 
#Make it into MP shape: add another write to y at the bottom of thread 0 and read it at the beginning of thread 1, to make it a cycle
